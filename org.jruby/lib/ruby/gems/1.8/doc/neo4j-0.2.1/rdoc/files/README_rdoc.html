<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>File: README.rdoc</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href=".././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



  <div id="fileHeader">
    <h1>README.rdoc</h1>
    <table class="header-table">
    <tr class="top-aligned-row">
      <td><strong>Path:</strong></td>
      <td>README.rdoc
      </td>
    </tr>
    <tr class="top-aligned-row">
      <td><strong>Last Update:</strong></td>
      <td>Mon May 25 11:41:03 +0300 2009</td>
    </tr>
    </table>
  </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">

    <div id="description">
      <h1>Neo4j.rb</h1>
<p>
Neo4j.rb is a graph database for JRuby.
</p>
<p>
It provides:
</p>
<ul>
<li>Mapping of ruby objects to nodes in networks rather than in tables.

</li>
<li>Dynamic, and schema-free - no need to declare
nodes/properties/relationships in advance.

</li>
<li>Storage of ruby object to a file system.

</li>
<li>Fast traversal of relationships between nodes in a huge node space.

</li>
<li>Transaction with rollbacks support.

</li>
<li>Indexing and querying of ruby objects.

</li>
<li>Can be used instead of ActiveRecord in Ruby on Rails or Merb

</li>
</ul>
<p>
It uses two powerful and mature java libraries:
</p>
<ul>
<li>Neo4J (<a href="http://www.neo4j.org">www.neo4j.org</a>/) - for persistance
and traversal of the graph

</li>
<li><a href="../classes/Lucene.html">Lucene</a> (<a
href="http://lucene.apache.org/java/docs/index.html">lucene.apache.org/java/docs/index.html</a>)
for quering and indexing.

</li>
</ul>
<h3>Status</h3>
<ul>
<li>There are over 250 RSpecs.

</li>
<li>Has been tested with a simple rails application, used Neo4j.rb instead of
ActiveRecord

</li>
<li>Has been load tested (loaded 18000 nodes and done queries/traversal in
several threads.)

</li>
<li>Has not been used in production yet (as far as I know).

</li>
</ul>
<h3>Project information</h3>
<ul>
<li>GitHub - <a
href="http://github.com/andreasronge/neo4j/tree/master">github.com/andreasronge/neo4j/tree/master</a>

</li>
<li>Issue Tracking - <a
href="http://neo4j.lighthouseapp.com">neo4j.lighthouseapp.com</a>

</li>
<li>Twitter - <a href="http://twitter.com/ronge">twitter.com/ronge</a>

</li>
<li>API Yard Documentation - <a
href="http://neo4j.rubyforge.org">neo4j.rubyforge.org</a>/

</li>
<li>Source repo - git://github.com/andreasronge/neo4j.git

</li>
</ul>
<h3>Presentation Materials and other URLs</h3>
<ul>
<li>Ruby Manor 2008 - Jonathan Conway: <a
href="http://jaikoo.com/assets/presentations/neo4j.pdf">jaikoo.com/assets/presentations/neo4j.pdf</a>

</li>
<li><a href="../classes/Neo4j.html">Neo4j</a> wiki - <a
href="http://wiki.neo4j.org/content/Main_Page">wiki.neo4j.org/content/Main_Page</a>
(check the guidelines and domain modeling gallery pages)

</li>
</ul>
<h3>License</h3>
<ul>
<li>Neo4j.rb - MIT, see the LICENSE file <a
href="http://github.com/andreasronge/neo4j/tree/master/LICENSE">github.com/andreasronge/neo4j/tree/master/LICENSE</a>.

</li>
<li><a href="../classes/Lucene.html">Lucene</a> - Apache, see <a
href="http://lucene.apache.org/java/docs/features.html">lucene.apache.org/java/docs/features.html</a>

</li>
<li><a href="../classes/Neo4j.html">Neo4j</a> - Dual free software/commercial
license, see <a href="http://neo4j.org">neo4j.org</a>/

</li>
</ul>
<h3>Content</h3>
<p>
This page contains the following information:
</p>
<ul>
<li>Installation guide

</li>
<li>Ten Minute Tutorial

</li>
<li><a href="../classes/Lucene.html">Lucene</a> API Documentation

</li>
<li><a href="../classes/Neo4j.html">Neo4j</a> API Documentation

</li>
<li>Ruby on Rails with Neo4j.rb

</li>
</ul>
<h2>Installation</h2>
<p>
To install it:
</p>
<pre>
   gem install neo4j
</pre>
<p>
To install from the latest source:
</p>
<pre>
  git clone git://github.com/andreasronge/neo4j.git
  cd neo4j
  rake gem:install
</pre>
<p>
This has been verified to work on JRuby 1.1.5 and 1.1.6 It does not work
with jruby 1.2.0RC2
</p>
<h4>Running all RSpecs</h4>
<p>
To check that neo4j.rb is working:
</p>
<pre>
  cd neo4j # the folder containing the Rakefile
  rake     # you may have to type jruby -S rake depending how you installed JRuby
</pre>
<h2>Ten Minute Tutorial</h2>
<h3>Creating a Model</h3>
<p>
The following example specifies how to map a <a
href="../classes/Neo4j.html">Neo4j</a> node to a Ruby Person instance.
</p>
<pre>
  require &quot;rubygems&quot;
  require &quot;neo4j&quot;

  class Person
    include Neo4j::NodeMixin

    # define Neo4j properties
    property :name, :salary.

    # define an one way relationship to any other node
    has_n :friends

    # adds a lucene index on the following properties
    index :name, :salary
    index 'friends.age' # index each friend age as well
  end
</pre>
<p>
Neo properties and relationships are declared using the
&#8216;property&#8217; and &#8216;has_n&#8217;/&#8217;has_one&#8217;
NodeMixin class method. Adding new types of properties and relationships
can also be done without using those class methods at an alread existing
node (see <a
href="../classes/Neo4j/DynamicAccessorMixin.html">Neo4j::DynamicAccessorMixin</a>).
</p>
<p>
By using the NodeMixin all instances of the Person class can now be stored
in the <a href="../classes/Neo4j.html">Neo4j</a> node space and be
retrieved/queried by traversing the node space or performing <a
href="../classes/Lucene.html">Lucene</a> queries.
</p>
<p>
A lucene index will be updated when the name or salary property changes.
The salary of all friends are also indexed which means we can query for
people who has friends with a certain salary.
</p>
<h3>Creating a node</h3>
<p>
Creating a Person node instance
</p>
<pre>
  person = Person.new
</pre>
<h3>Setting properties</h3>
<p>
Setting a property:
</p>
<pre>
  person.name = 'kalle'
  person.salary  = 10000
</pre>
<p>
If a transaction is not specified then the operation will automatically be
wrapped in a transaction.
</p>
<h3><a href="../classes/Lucene.html">Lucene</a> Queries</h3>
<p>
There are different ways to write queries. Using a hash:
</p>
<pre>
  Person.find (:name =&gt; 'kalle', :age =&gt; 20..30)  # find people with name kalle and age between 20 and 30
</pre>
<p>
or using the lucene query language:
</p>
<pre>
  Person.find(&quot;name:kalle AND salary:[10000 TO 30000]&quot;)
</pre>
<p>
The <a href="../classes/Lucene.html">Lucene</a> query language supports
wildcard, grouping, boolean, fuzzy queries, etc&#8230; For more information
see: <a
href="http://lucene.apache.org/java/2_4_0/queryparsersyntax.html">lucene.apache.org/java/2_4_0/queryparsersyntax.html</a>
</p>
<h3>Sorting, example</h3>
<pre>
  Person.find(:name =&gt; 'kalle').sort_by(:salary)
  Person.find(:name =&gt; 'kalle').sort_by(Desc[:salary], Asc[:country])
  Person.find(:name =&gt; 'kalle').sort_by(Desc[:salary, :country])
</pre>
<h3>Search Results</h3>
<p>
The query is not performed until the search result is requested. Example of
using the search result.
</p>
<pre>
  res = Person.find(:name =&gt; 'kalle')
  res.size  # =&gt; 10
  res.each {|x| puts x.name}
  res[0].name = 'sune'
</pre>
<h3>Creating a Relationships</h3>
<p>
Adding a relationship between two nodes:
</p>
<pre>
  person2 = Person.new
  person.friends &lt;&lt; person2
</pre>
<h3>Deleting a Relationship</h3>
<p>
To delete the relationship between person and person2:
</p>
<pre>
  person.relations[person2].delete
</pre>
<p>
If a node is deleted then all its relationship will also be deleted
Deleting a node is performed by using the delete method:
</p>
<pre>
  person.delete
</pre>
<h3>Node Traversals</h3>
<p>
The has_one and has_many methods create a convenient method for traversals
and managing relationships to other nodes. Example:
</p>
<pre>
  Person.has_n :friends # generates the friends instance method
  # all instances of Person now has a friends method so that we can do the following
  person.friends.each {|n| ...  }
</pre>
<p>
Traversing using a filter
</p>
<pre>
  person.friends{ salary == 10000 }.each {|n| ...}
</pre>
<p>
Traversing with a specific depth (depth 1 is default)
</p>
<pre>
  person.friends{ salary == 10000}.depth(3).each { ... }
</pre>
<p>
There is also a more powerful method for traversing several relationships
at the same time - Neo4j::NodeMixin#traverse, see below.
</p>
<h3>Example on Relationships</h3>
<p>
In the first example the friends relationship can have relationships to any
other node of any class. In the next example we specify that the
&#8216;acted_in&#8217; relationship should use the Ruby classes Actor, Role
and Movie. This is done by using the has_n class method:
</p>
<pre>
      class Role
        include Neo4j::RelationMixin
        # notice that neo4j relationships can also have properties
        property :name
      end

      class Actor
        include Neo4j::NodeMixin

        # The following line defines the acted_in relationship
        # using the following classes:
        # Actor[Node] --(Role[Relation])--&gt; Movie[Node]
        #
        has_n(:acted_in).to(Movie).relation(Role)
      end

      class Movie
        include Neo4j::NodeMixin
        property :title
        property :year

        # defines a method for traversing incoming acted_in relationships from Actor
        has_n(:actors).from(Actor, :acted_in)
      end
</pre>
<p>
Creating a new Actor-Role-Movie relationship can be done like this:
</p>
<pre>
      keanu_reeves = Actor.new
      matrix       = Movie.new
      keanu_reeves.acted_in &lt;&lt; matrix
</pre>
<p>
or you can also specify this relationship on the incoming node (since we
provided that information in the has_n methods).
</p>
<pre>
      keanu_reeves = Actor.new
      matrix       = Movie.new
      matrix.actors &lt;&lt; keanu_reeves
</pre>
<p>
Example of accessing the Role relationship object between an Actor and a
Movie
</p>
<pre>
      keanu_reeves.relations.outgoing(:acted_in)[matrix].name = 'neo'
</pre>
<p>
More information about neo4j can be found after the <a
href="../classes/Lucene.html">Lucene</a> section below.
</p>
<h2>The <a href="../classes/Lucene.html">Lucene</a> Module</h2>
<p>
You can use this module without using the <a
href="../classes/Neo4j.html">Neo4j</a> module.
</p>
<p>
<a href="../classes/Lucene.html">Lucene</a> provides:
</p>
<ul>
<li>Flexible Queries - Phrases, Wildcards, Compound boolean expressions
etc&#8230;

</li>
<li>Field-specific Queries eg. title, artist, album

</li>
<li>Sorting

</li>
<li>Ranked Searching

</li>
</ul>
<h3><a href="../classes/Lucene.html">Lucene</a> Document</h3>
<p>
In lucene everything is a Document. A document can represent anything
textual: Word Document, DVD (the textual metadata only), or a Neo4j.rb
node. A document is like a record or row in a relation database.
</p>
<p>
The following example shows how a document can be created by using the
&#8217;&#8217;&lt;&lt;&#8217;&#8217; operator on the <a
href="../classes/Lucene/Index.html">Lucene::Index</a> class and found using
the Lucene::Index#find method.
</p>
<p>
Example of how to write a document and find it:
</p>
<pre>
    require 'lucene'

    include Lucene

    # the var/myindex parameter is either a path where to store the index or
    # just a key if index is kept in memory (see below)
    index = Index.new('var/myindex')

    # add one document (a document is like a record or row in a relation database)
    index &lt;&lt; {:id=&gt;'1', :name=&gt;'foo'}

    # write to the index file
    index.commit

    # find a document with name foo
    # hits is a ruby Enumeration of documents
    hits = index.find{name == 'foo'}

    # show the id of the first document (document 0) found
    # (the document contains all stored fields - see below)
    hits[0][:id]   # =&gt; '1'
</pre>
<p>
Notice that you have to call the commit method in order to update the index
on the disk/RAM. By performing several update and delete operations before
a commit will be much faster then performing commit after each operation.
</p>
<h3>Keep indexing on disk</h3>
<p>
By default <a href="../classes/Lucene.html">Neo4j::Lucene</a> keeps indexes
in memory. That means that when the application restarts the index will be
gone and you have to reindex everything again.
</p>
<p>
To keep indexes in memory:
</p>
<pre>
   Lucene::Config[:store_on_file] = true
   Lucene::Config[:storage_path] =&gt; '/home/neo/lucene-db'
</pre>
<p>
When creating a new index the location of the index will be the <a
href="../classes/Lucene/Config.html">Lucene::Config</a>[:storage_path] +
index path Example:
</p>
<pre>
   Lucene::Config[:store_on_file] = true
   Lucene::Config[:storage_path] =&gt; '/home/neo/lucene-db'
   index = Index.new('/foo/lucene')
</pre>
<p>
The example above will store the index at /home/neo/lucene-db/foo/lucene
</p>
<h3>Indexing several values with the same key</h3>
<p>
Let say a person can have several phone numbers. How do we index that ?
</p>
<pre>
  index &lt;&lt; {:id=&gt;'1', :name=&gt;'adam', :phone =&gt; ['987-654', '1234-5678']}
</pre>
<h3>Id field</h3>
<p>
All Documents must have one id field. If one is not specified it is :id of
type String. A different id can be specified using the field_infos id_field
property on the index:
</p>
<pre>
  index = Index.new('some/path/to/the/index')
  index.field_infos.id_field = :my_id
</pre>
<p>
To change the type of the my_id from String to a different type see below.
</p>
<h3>Conversion of types</h3>
<p>
Lucene.rb can handle type conversion for you. (The java lucene library
stores all the fields as Strings) For example if you want the id field to
be a fixnum
</p>
<pre>
    require 'lucene'
    include Lucene

    index = Index.new('var/myindex')  # store the index at dir: var/myindex
    index.field_infos[:id][:type] = Fixnum

    index &lt;&lt; {:id=&gt;1, :name=&gt;'foo'} # notice 1 is not a string now

    index.commit

    # find that document, hits is a ruby Enumeration of documents
    hits = index.find(:name =&gt; 'foo')

    # show the id of the first document (document 0) found
    # (the document contains all stored fields - see below)
    doc[0][:id]   # =&gt; 1
</pre>
<p>
If the field_info type parameter is not set then it has a default value of
String.
</p>
<h3>Storage of fields</h3>
<p>
By default only the id field will be stored. That means that in the example
above the :name field will not be included in the document.
</p>
<p>
Example
</p>
<pre>
    doc = index.find('name' =&gt; 'foo')
    doc[:id]   # =&gt; 1
    doc[:name] # =&gt; nil
</pre>
<p>
Use the field info :store=true if you want a field to be stored in the
index (otherwise it will only be searchable).
</p>
<p>
Example
</p>
<pre>
    require 'lucene'
    include Lucene

    index = Index.new('var/myindex')  # store the index at dir: var/myindex
    index.field_infos[:id][:type] = Fixnum
    index.field_infos[:name][:store] = true # store this field

    index &lt;&lt; {:id=&gt;1, :name=&gt;'foo'} # notice 1 is not a string now

    index.commit

    # find that document, hits is a ruby Enumeration of documents
    hits = index.find('name' =&gt; 'foo')

    # let say hits only contains one document so we can use doc[0] for that one
    # that document contains all stored fields (see below)
    doc[0][:id]   # =&gt; 1
    doc[0][:name] # =&gt; 'foo'
</pre>
<h3>Setting field infos</h3>
<p>
As shown above you can set field infos like this
</p>
<pre>
  index.field_infos[:id][:type] = Fixnum
</pre>
<p>
Or you can set several properties like this:
</p>
<pre>
  index.field_infos[:id] = {:type =&gt; Fixnum, :store =&gt; true}
</pre>
<h3>Simple Queries</h3>
<p>
Lucene.rb support search in several fields: Example
</p>
<pre>
    # finds all document having both name 'foo' and age 42
    hits = index.find('name' =&gt; 'foo', :age=&gt;42)
</pre>
<p>
Range queries
</p>
<pre>
    # finds all document having both name 'foo' and age between 3 and 30
    hits = index.find('name' =&gt; 'foo', :age=&gt;3..30)
</pre>
<h3><a href="../classes/Lucene.html">Lucene</a> Queries</h3>
<p>
If the query is string then the string is a lucene query.
</p>
<pre>
  hits = index.find('name:foo')
</pre>
<p>
For more information see: <a
href="http://lucene.apache.org/java/2_4_0/queryparsersyntax.html">lucene.apache.org/java/2_4_0/queryparsersyntax.html</a>
</p>
<h3>Advanced Queries (DSL)</h3>
<p>
The queries above can also be written in a lucene.rb DSL:
</p>
<pre>
    hits = index.find { (name == 'andreas') &amp; (foo == 'bar')}
</pre>
<p>
Expression with OR (|) is supported, example
</p>
<pre>
   # find all documents with name 'andreas' or age between 30 and 40
    hits = index.find { (name == 'andreas') | (age == 30..40)}
</pre>
<h3>Sorting</h3>
<p>
Sorting is specified by the &#8216;sort_by&#8217; parameter Example
</p>
<pre>
  hits = index.find(:name =&gt; 'foo', :sort_by=&gt;:category)
</pre>
<p>
To sort by several fields:
</p>
<pre>
  hits = index.find(:name =&gt; 'foo', :sort_by=&gt;[:category, :country])
</pre>
<p>
Example sort order
</p>
<pre>
  hits = index.find(:name =&gt; 'foo', :sort_by=&gt;[Desc[:category, :country], Asc[:city]])
</pre>
<h3>Thread-safety</h3>
<p>
The <a href="../classes/Lucene/Index.html">Lucene::Index</a> is thread
safe. It guarantees that an index is not updated from two thread at the
same time.
</p>
<h3><a href="../classes/Lucene.html">Lucene</a> Transactions</h3>
<p>
Use the <a
href="../classes/Lucene/Transaction.html">Lucene::Transaction</a> in order
to do atomic commits. By using a transaction you do not need to call the
Index.commit method.
</p>
<p>
Example:
</p>
<pre>
    Transaction.run do |t|
      index = Index.new('var/index/foo')
      index &lt;&lt; { id=&gt;42, :name=&gt;'andreas'}
      t.failure  # rollback
    end

    result = index.find('name' =&gt; 'andreas')
    result.size.should == 0
</pre>
<p>
You can find which documents are uncommited by using the uncommited index
property.
</p>
<p>
Example
</p>
<pre>
      index = Index.new('var/index/foo')
      index.uncommited #=&gt; [document1, document2]
</pre>
<p>
Notice that even if it looks like a new Index instance object was created
the index.uncommited may return an not empty array. This is because
Index.new is a singleton - a new instance object is not created.
</p>
<h2>The <a href="../classes/Neo4j.html">Neo4j</a> Module</h2>
<p>
The <a href="../classes/Neo4j.html">Neo4j</a> module is used to map Ruby
objects to nodes and relationships in a network. It supports two different
ways of retrieval/quering:
</p>
<ul>
<li><a href="../classes/Neo4j.html">Neo4j</a> traversal,
Neo4j::NodeMixin#traverse (or Neo4j::NodeMixin#has_n)

</li>
<li><a href="../classes/Lucene.html">Lucene</a> indexes, Neo4j::NodeMixin#find

</li>
</ul>
<h3>Start and Stop of the <a href="../classes/Neo4j.html">Neo4j</a></h3>
<p>
Unlike the Java <a href="../classes/Neo4j.html">Neo4j</a> implementation it
is not neccessarly to start <a href="../classes/Neo4j.html">Neo4j</a>. It
will automatically be started when needed. It also uses a hook to
automatically shutdown <a href="../classes/Neo4j.html">Neo4j</a>. Shutdown
of neo4j can also be done using the stop method, example:
</p>
<pre>
  Neo4j.stop
</pre>
<h4><a href="../classes/Neo4j.html">Neo4j</a> Configuration</h4>
<p>
Before using <a href="../classes/Neo4j.html">Neo4j</a> the location where
the database is stored on disk should be configured. The neo4j
configuration is kept in the <a
href="../classes/Neo4j/Config.html">Neo4j::Config</a> class:
</p>
<pre>
   Neo4j::Config[:storage_path] = '/home/neo/neodb'
</pre>
<h3><a href="../classes/Lucene.html">Lucene</a> Integration</h3>
<p>
Neo4j.rb uses the <a href="../classes/Lucene.html">Lucene</a> module. That
means that the <a
href="../classes/Neo4j/NodeMixin.html">Neo4j::NodeMixin</a> has method for
both traversal and lucene queries/indexing.
</p>
<h4><a href="../classes/Lucene.html">Lucene</a> Configuration</h4>
<p>
By default lucene indexes are kept in memory. Keeping index in memory will
increase the performance of lucene operations (such as updating the index).
</p>
<p>
Example to configure <a href="../classes/Lucene.html">Lucene</a> to store
indexes on disk instead
</p>
<pre>
   Lucene::Config[:store_on_file] = true
   Lucene::Config[:storage_path] =&gt; '/home/neo/lucene-db'
</pre>
<h4><a href="../classes/Lucene.html">Lucene</a> Index in Memory</h4>
<p>
If index is stored in memory then one needs to reindex all nodes when the
application starts up again.
</p>
<pre>
   MyNode.update_index # will traverse all MyNode instances and (re)create the lucene index in memory.
</pre>
<h3><a href="../classes/Neo4j/NodeMixin.html">Neo4j::NodeMixin</a></h3>
<p>
<a href="../classes/Neo4j/NodeMixin.html">Neo4j::NodeMixin</a> is a mixin
that lets instances to be stored as a node in the neo node space on disk. A
node can have properties and relationships to other nodes.
</p>
<p>
Example of how declare a class that has this behaviour:
</p>
<pre>
  class MyNode
     include Neo4j::NodeMixin
  end
</pre>
<h3>Create a Node</h3>
<p>
If a block is provided then the creation of the instance will be performed
in an transaction, see below for more information on transactions.
</p>
<pre>
  node = MyNode.new { }
</pre>
<h3>Delete a Node</h3>
<p>
The <a href="../classes/Neo4j/NodeMixin.html">Neo4j::NodeMixin</a> mixin
defines a delete method that will delete the node and all its
relationships.
</p>
<p>
Example:
</p>
<pre>
  node = MyNode.new
  node.delete
</pre>
<p>
The node in the example above will be removed from the neo database on the
filesystem and the lucene index
</p>
<h3>Node Properties</h3>
<p>
In order to use properties they have to be declared first
</p>
<pre>
  class MyNode
     include Neo4j::NodeMixin
     property :foo, :bar
  end
</pre>
<p>
These properties (foo and bar) will be stored in the Neo database. You can
set those properties:
</p>
<pre>
  # create a node with two properties in one transaction
  node = MyNode.new { |n|
     n.foo = 123
     n.bar = 3.14
  }

  # access those properties
  puts node.foo
</pre>
<p>
You can also set a property like this:
</p>
<pre>
    f = SomeNode.new
    f.foo = 123
</pre>
<p>
Neo4j.rb supports properties to by of type String, Fixnum, Float and
true/false
</p>
<h3>Property Types and Marshalling</h3>
<p>
If you want to set a property of a different type then String, Fixnum,
Float or true/false you have to specify its type.
</p>
<p>
Example, to set a property to any type
</p>
<pre>
  class MyNode
    include Neo4j::NodeMixin
    property :foo, :type =&gt; Object
  end

  node = MyNode.new
  node.foo = [1,&quot;3&quot;, 3.14]

  Neo4j.load(node.neo_node_id).foo.class # =&gt; Array
</pre>
<h3>Property of type Date and DateTime</h3>
<p>
Example of using Date queries:
</p>
<pre>
  class MyNode
    include Neo4j::NodeMixin
    property :since, :type =&gt; Date
    index :since, :type =&gt; Date
  end

  node.since = Date.new 2008,05,06
  MyNode.find(&quot;born:[20080427 TO 20100203]&quot;)[0].since # =&gt; Date 2008,05,06
</pre>
<p>
Example of using DateTime queries:
</p>
<pre>
  class MyNode
    include Neo4j::NodeMixin
    property :since, :type =&gt; DateTime
    index :since, :type =&gt; DateTime
  end

  node.since = DateTime.civil 2008,04,27,15,25,59
  MyNode.find(&quot;since:[200804271504 TO 201002031534]&quot;)[0].since # =&gt; DateTime ...
</pre>
<p>
Only UTC timezone is allowed.
</p>
<h3>Finding all nodes</h3>
<p>
To find all nodes of a specific type use the all method. Example
</p>
<pre>
  class Car
    include Neo4j::Node
    property :wheels
  end

  class Volvo &lt; Car
  end

  v = Volvo.new
  c = Car.new

  Car.all   # will return all relationships from the reference node to car obejcts
  Volvo.all # will return the same as Car.all
</pre>
<p>
To return nodes (just like the relations method)
</p>
<pre>
  Car.all.nodes    # =&gt; [c,v]
  Volvo.all.nodes  # =&gt; [c,v]
</pre>
<h3>Relationship has_n and has_one</h3>
<p>
Neo relationships are none symmetrical. That means that if A has a relation
to B then it may not be true that B has a relation to A.
</p>
<p>
Relationships can be declared by using the &#8216;has_n&#8217; or
&#8216;has_one&#8217; <a
href="../classes/Neo4j/NodeMixin.html">Neo4j::NodeMixin</a> class methods.
</p>
<h4>has_n</h4>
<p>
The has_n <a href="../classes/Neo4j/NodeMixin.html">Neo4j::NodeMixin</a>
class method creates a new instance method that can be used for both
traversing and adding new objects to a specific relationship type.
</p>
<p>
For example, let say that Person can have a relationship to any other node
class with the type &#8216;friends&#8217;:
</p>
<pre>
  class Person
     include Neo::Node
     has_n :knows  # will generate a knows method for outgoing relationships
  end
</pre>
<p>
The generated knows method will allow you to add new relationships,
example:
</p>
<pre>
  me = Person.new
  neo = Person.new
  me.knows &lt;&lt; neo  # me knows neo but neo does not know me
</pre>
<p>
You can add any object to the &#8216;knows&#8217; relationship as long as
it includes the <a
href="../classes/Neo4j/NodeMixin.html">Neo4j::NodeMixin</a>, example:
</p>
<pre>
  person = Person.new
  car = Volvo.new # Volvo is a class that includes the Neo4j::NodeMixin
  person.knows &lt;&lt; car
</pre>
<p>
If you want to express that the relationship should point to a specific
class use the &#8216;to&#8217; method on the has_n method.
</p>
<pre>
  class Person
     include Neo::Node
     has_n(:knows).to(Person)
  end
</pre>
<p>
It is also possible to generate methods for incoming relationships by using
the &#8216;from&#8217; method on the has_n method.
</p>
<p>
Example:
</p>
<pre>
  class Person
     include Neo::Node
     has_n :knows  # will generate a knows method for outgoing relationships
     has_n(:known_by).from(:knows)  #  will generate a known_by method for incomming knows relationship
  end
</pre>
<p>
By doing this you can add a relationships on either the incoming or
outgoing node. The from method can also take an additional class parameter
if it has incoming nodes from a different node class (see the
Actor-Role-Movie example at the top of this document).
</p>
<p>
Example of adding a &#8216;knows&#8217; relationship from the other node:
</p>
<pre>
  me = Person.new
  neo = Person.new
  neo.known_by &lt;&lt; me # me knows neo but neo does not know me
</pre>
<p>
The known_by method creates a &#8216;knows&#8217; relationship between the
me and neo nodes. This is the same as doing:
</p>
<pre>
  me.knows &lt;&lt; neo # me knows neo but neo does not know me
</pre>
<h4>Relationship has_one</h4>
<p>
Example of has_one: A person can have at most one Address
</p>
<pre>
      class Person
        include Neo4j::NodeMixin
        has_one(:address).to(Address)
      end

      class Address
        include Neo4j::NodeMixin
        property :city, :road
        has_n(:people).from(Person, :address)
      end
</pre>
<p>
In the example above we have Neo4j.rb will generate the following methods
</p>
<ul>
<li>in Person, the method &#8217;&#8217;address=&#8217;&#8217; and
&#8217;&#8217;address&#8217;&#8217;

</li>
<li>in Address, the traversal method &#8217;&#8217;people&#8217;&#8217; for
traversing incomming relationships from the Person node.

</li>
</ul>
<p>
Example of usage:
</p>
<pre>
      p = Person.new
      p.address = Address.new
      p.address.city = 'malmoe'
</pre>
<p>
Or from the incoming &#8217;&#8217;address&#8217;&#8217; relationship
</p>
<pre>
      a = Address.new {|n| n.city = 'malmoe'}
      a.people &lt;&lt; Person.new
</pre>
<h4>Traversing has_n Relationships</h4>
<p>
Each type of relationship has a method that returns an Enumerable object
that enables you to traverse that type of relationship.
</p>
<p>
For example the Person example above declares one relationship of type
friends. You can traverse all Person&#8216;s friend (depth 1 is default)
</p>
<pre>
  f.friends.each { |n| puts n }
</pre>
<p>
It is also possible to traverse a relationship of an arbitrary depth.
Example finding all friends and friends friends.
</p>
<pre>
  f.friends.depth(2).each { ...}
</pre>
<p>
Traversing to the end of the graph
</p>
<pre>
  f.friends.depth(:all).each { ...}
</pre>
<h4>Filtering Nodes</h4>
<p>
If you want to find one node in a relationship you can use a filter.
Example, let say we want to find a friend with name &#8216;andreas&#8216;
</p>
<pre>
  n1 = Person.new
  n2 = Person.new {|n| n.name = 'andreas'}
  n3 = Person.new
  n1.friends &lt;&lt; n2 &lt;&lt; n3
  n1.friends{ name == 'andreas' }.to_a # =&gt; [n2]
</pre>
<p>
The block { name == &#8216;andreas&#8217; } will be evaluated on each node
in the relationship. If the evaluation returns true the node will be
included in the filter search result.
</p>
<h3>Traversing Nodes</h3>
<p>
The Neo4j::NodeMixin#traverse method is a more powerful method compared to
the generated has_n and has_one methods. Unlike those generated method it
can traverse several relationship types at the same time. The types of
relationships being traversed must therefore always be specified in the
incoming, outgoing or both method. Those three methods can take one or more
relationship types parameters if more then one type of relationship should
be traversed.
</p>
<h4>Traversing Nodes of Arbitrary Depth</h4>
<p>
The depth method allows you to specify how deep the traverse should be. If
not specified only one level traverse is done.
</p>
<p>
Example:
</p>
<pre>
  me.traverse.incoming(:friends).depth(4).each {} # =&gt; people with a friend relationship to me
</pre>
<h4>Traversing Nodes With Several Relationship Types</h4>
<p>
It is possible to traverse sevaral relationship types at the same type. The
incoming, both and outgoing methods takes list of arguments.
</p>
<p>
Example, given the following holiday trip domain:
</p>
<pre>
  # A location contains a hierarchy of other locations
  # Example region (asia) contains countries which contains  cities etc...
  class Location
    include Neo4j::NodeMixin
    has_n :contains
    has_n :trips
    property :name
    index :name

  # A Trip can be specific for one global area, such as &quot;see all of sweden&quot; or
  # local such as a 'city tour of malmoe'
  class Trip
    include Neo4j::NodeMixin
    property :name
  end

  # create all nodes
  # ...

  # setup the relationship between all nodes
  @europe.contains &lt;&lt; @sweden &lt;&lt; @denmark
  @sweden.contains &lt;&lt; @malmoe &lt;&lt; @stockholm

  @sweden.trips &lt;&lt; @sweden_trip
  @malmoe.trips &lt;&lt; @malmoe_trip
  @malmoe.trips &lt;&lt; @city_tour
  @stockholm.trips &lt;&lt; @city_tour # the same city tour is available both in malmoe and stockholm
</pre>
<p>
Then we can traverse both the contains and the trips relationship types
Example:
</p>
<pre>
  @sweden.traverse.outgoing(:contains, :trips).to_a # =&gt; [@malmoe, @stockholm, @sweden_trip]
</pre>
<p>
It is also possible to traverse both incoming and outgoing relationships,
example:
</p>
<pre>
  @sweden.traverse.outgoing(:contains, :trips).incoming(:contains).to_a # =&gt; [@malmoe, @stockholm, @sweden_trip, @europe]
</pre>
<h4>Traversing Nodes With a Filter</h4>
<p>
It&#8216;s possible to filter which nodes should be returned from the
traverser by using the filter function. This filter function will be
evaluated differently depending on if it takes one argument or no
arguments, see below.
</p>
<h4>Filtering: Using Evaluation in the Context of the Current Node</h4>
<p>
If the provided filter function does not take any parameter it will be
evaluted in the context of the current node being traversed. That means
that one can writer filter functions like this:
</p>
<pre>
  @sweden.traverse.outgoing(:contains, :trips).filter { name == 'sweden' }
</pre>
<h4>Filtering: Using the TraversalPostion</h4>
<p>
If the filter method takes one parameter then it will be given an object of
type TraversalPosition which contains information about current node, how
many nodes has been returned, depth etc.
</p>
<p>
The information contained in the TraversalPostion can be used in order to
decide if the node should included in the traversal search result. If the
provided block returns true then the node will be included in the search
result.
</p>
<p>
The filter function will not be evaluated in the context of the current
node when this parameter is provided.
</p>
<p>
The TraversalPosition is a wrapper of java interface TraversalPosition, see
<a
href="http://api.neo4j.org/current/org/neo4j/api/core/TraversalPosition.html">api.neo4j.org/current/org/neo4j/api/core/TraversalPosition.html</a>
</p>
<p>
For example if we only want to return the Trip objects in the example
above:
</p>
<pre>
  # notice how the tp (TraversalPosition) parameter is used in order to only
  # return nodes included in a 'trips' relationship.
  traverser = @sweden.traverse.outgoing(:contains, :trips).filter do |tp|
    tp.last_relationship_traversed.relationship_type == :trips
  end

  traverser.to_a # =&gt; [@sweden_trip]
</pre>
<h3>Relationships</h3>
<p>
A relationship between two nodes can have properties just like a node.
</p>
<p>
Example:
</p>
<pre>
  p1 = Person.new
  p2 = Person.new

  relation = p1.friends.new(p2)

  # set a property 'since' on this relationship bewteen p1 and p2
  relation.since = 1992
</pre>
<p>
If a Relationship class has not been specified for a relationship then any
properties can be set on the relationship. It has a default relationship
class: Neo4j::DynamicRelation
</p>
<p>
If you instead want to use your own class for a relationship use the
Neo4j::NodeMixin#has_n.relation method, example:
</p>
<pre>
      class Role
        # This class can be used as the relationship between two nodes
        # since it includes the following mixin
        include Neo4j::RelationMixin
        property :name
      end

      class Actor
        include Neo4j::NodeMixin
        # use the Role class above in the relationship between Actor and Movie
        has_n(:acted_in).to(Movie).relation(Role)
      end
</pre>
<h3>Finding Relationships</h3>
<p>
The Neo4j::NodeMixin#relations method can be used to find incoming or
outgoing relationship objects. Example of listing all types of outgoing
(default) relation objects (of depth one) from the me node.
</p>
<pre>
  me.relations.each {|rel| ... }
</pre>
<p>
If we instead want to list the nodes that those relationships points to
then the nodes method can be used.
</p>
<pre>
  me.relations.nodes.each {|rel| ... }
</pre>
<p>
Listing all incoming relationship obejcts of any relationship type:
</p>
<pre>
  me.relations.incoming.each { ... }
</pre>
<p>
Listing both incoming and outgoing relationship object of a specific type:
</p>
<pre>
  me.relations.both(:friends) { }
</pre>
<p>
Finding one outgoing relationship of a specific type and node (you)
</p>
<pre>
  me.relations.outgoing(:friends)[you] # =&gt; [#&lt;Neo4j::RelationMixin:0x134ae32]
</pre>
<h4>Finding Relationships Example</h4>
<p>
Example, given we have the two nodes with a relationship between them:
</p>
<pre>
  n1 = Person.new
  n2 = Person.new

  n1.friends &lt;&lt; n2
</pre>
<p>
Then we can find all incoming and outgoing relationships like this:
</p>
<pre>
  n1.relations.to_a # =&gt; [#&lt;Neo4j::RelationMixin:0x134ae32]
</pre>
<p>
A <a href="../classes/Neo4j/RelationMixin.html">Neo4j::RelationMixin</a>
object represents a relationship between two nodes.
</p>
<pre>
  n1.relations[0].start_node # =&gt; n1
  n1.relations[0].end_node # =&gt; n2
</pre>
<p>
A RelationMixin contains the relationship type which connects it connects
two nodes with, example:
</p>
<pre>
  n1.relations[0].relationship_type # =&gt; :friends
</pre>
<p>
Relationships can also have properties just like a node (NodeMixin).
</p>
<h3>Finding outgoing and incoming relationships</h3>
<p>
If we are only interested in all incoming nodes, we can do
</p>
<pre>
  n2.relations.incoming # =&gt; [#&lt;Neo4j::RelationMixin:0x134ae32]
</pre>
<p>
Or outgoing:
</p>
<pre>
  n1.relations.outgoing # =&gt; [#&lt;Neo4j::RelationMixin:0x134aea2]
</pre>
<p>
To find a specific relationship use the [] operator:
</p>
<pre>
  n1.relations.outgoing[n2] = #&lt;Neo4j::RelationMixin:0x134aea2
</pre>
<p>
Or which is better performance wise (since only friends relationships are
being traversed):
</p>
<pre>
  n1.relations.outgoing(:friends)[n2] = #&lt;Neo4j::RelationMixin:0x134aea2
</pre>
<h3>Deleting a relationship</h3>
<p>
Use the Neo4j::RelationMixin#delete method. For example, to delete the
relationship between n1 and n2 from the example above:
</p>
<pre>
    n1.relations.outgoing(:friends)[n2].delete
</pre>
<h3>Finding nodes in a relationship</h3>
<p>
If you do not want those relationship object but instead want the nodes you
can use the &#8216;nodes&#8217; method in the <a
href="../classes/Neo4j/RelationMixin.html">Neo4j::RelationMixin</a> object.
</p>
<p>
For example:
</p>
<pre>
  n2.relations.incoming.nodes # =&gt; [n1]
</pre>
<h3>Finding outgoing/incoming nodes of a specific relationship type</h3>
<p>
Let say we want to find who has my phone number and who consider me as a
friend
</p>
<pre>
  # who has my phone numbers
  me.relations.incoming(:phone_numbers).nodes # =&gt; people with my phone numbers

  # who consider me as a friend
  me.relations.incoming(:friends).nodes # =&gt; people with a friend relationship to me
</pre>
<p>
Remember that relationships are not symmetrical. Notice there is also a
otherway of finding nodes, see the Neo4j::NodeMixin#traverse method below.
</p>
<h3>Transactions</h3>
<p>
All operations that work with the node space (even read operations) must be
wrapped in a transaction. Luckly neo4j.rb will automatically create a
transaction for those operation that needs it if one is not already
provided.
</p>
<p>
For example all get, set and find operations will start a new transaction
if none is already not runnig (for that thread).
</p>
<p>
If you want to perform a set of operation in a single transaction, use the
Neo4j::Transaction.run method:
</p>
<p>
Example
</p>
<pre>
  Neo4j::Transaction.run {
    node1.foo = &quot;value&quot;
    node2.bar = &quot;hi&quot;
  }
</pre>
<p>
There is also a TransactionalMixin that lets you declare which method
should be wrapped inside a transaction. Example:
</p>
<pre>
  class Person
    include Neo4j::NodeMixin
    extend Neo4j::TransactionalMixin

    property :name, :age

    def do_stuff
      # ... no transaction stuff needed to be written here.
    end

    transactional :do_stuff
  end
</pre>
<h4>Rollback</h4>
<p>
<a href="../classes/Neo4j.html">Neo4j</a> support rollbacks on transaction.
Example: Example:
</p>
<pre>
  include 'neo4j'

  node = MyNode.new

  Neo4j::Transaction.run { |t|
     node.foo = &quot;hej&quot;
     # something failed so we signal for a failure
     t.failure # will cause a rollback, node.foo will not be updated
  }
</pre>
<p>
You can also run it without a block, like this:
</p>
<pre>
   transaction = Neo4j::Transaction.new
   transaction.start
   # do something
   transaction.finish
</pre>
<h3>Indexing</h3>
<p>
Properties and relationships which should be indexed by lucene can be
specified by the index class method. For example to index the proeprties
foo and bar
</p>
<pre>
  class SomeNode
     include Neo4j::NodeMixin
     property :foo, :bar
     index :foo, :bar
  end
</pre>
<p>
Everytime a node of type SomeNode (or a subclass) is create, deleted or
updated the lucene index of will be updated.
</p>
<h3>Updating <a href="../classes/Lucene.html">Lucene</a> Index</h3>
<p>
Sometimes it&#8216;s neccessarly to change the index of a class after alot
of node instances already have been created. To delete an index use the
class method &#8216;remove_index&#8217; To update an index use the class
method &#8216;update_index&#8217; which will update all already created
nodes in the neo database.
</p>
<p>
Example
</p>
<pre>
  class Person
    include Neo4j
    property :name, :age, :phone
    index :name, :age
  end

  p1 = Person.new {|n| n.name = 'andreas'; n.phone = 123}
  Person.find (:name =&gt; 'andreas') # =&gt; [p1]
  Person.find (:phone =&gt; 123) # =&gt; []

  # change index and reindex all person nodes already created in the neo database.
  Person.remove_index :name
  Person.index :phone  # add an index on phone
  Person.update_index

  Person.find (:name =&gt; 'andreas') # =&gt; []
  Person.find (:phone =&gt; 123) # =&gt; [p1]
</pre>
<h3>Quering (using lucene)</h3>
<p>
You can declare properties to be indexed by lucene by the index method:
</p>
<p>
Example
</p>
<pre>
      class Person
        include Neo4j::NodeMixin
        property :name, :age
        index :name, :age
      end

      node = Person.new
      node.name = 'foo'
      node.age  = 42

      Person.find(:name =&gt; 'foo', :age =&gt; 42) # =&gt; [node]
</pre>
<p>
The query parameter (like property on a <a
href="../classes/Neo4j/NodeMixin.html">Neo4j::NodeMixin</a>) can be of type
String, Fixnum, Float, boolean or Range. The query above can also be
written in a lucene query DSL:
</p>
<pre>
      Person.find{(name =='foo') &amp; (age =&gt; 42)} # =&gt; [node]
</pre>
<p>
Or lucene query language:
</p>
<pre>
     Person.find(&quot;name:foo AND age:42&quot;)
</pre>
<p>
For more information see: <a
href="http://lucene.apache.org/java/2_4_0/queryparsersyntax.html">lucene.apache.org/java/2_4_0/queryparsersyntax.html</a>
or the lucene module above.
</p>
<h3>Indexing and Property Types</h3>
<p>
In order to use range querie on numbers the property types must be
converted. This is done by using the :type optional parameter:
</p>
<pre>
  class Person
    include Neo4j::NodeMixin
    property :name, :age
    index :age, :type =&gt; Fixnum
  end
</pre>
<p>
By using :type =&gt; Fixnum the age will be padded with &#8216;0&#8216;s
(lucene only support string comparsion).
</p>
<p>
Example, if the :type =&gt; Fixnum was not specified then
</p>
<pre>
  p = Person.new {|n| n.age = 100 }
  Person.find(:age =&gt; 0..8) # =&gt; [p]
</pre>
<h3>Indexing and Quering Relationships</h3>
<p>
The Neo4j::NodeMixin#index method can be used to index relationships to
other classes.
</p>
<p>
Example, let say we have to classes, Customer and Orders:
</p>
<pre>
  class Customer
    include Neo4j::NodeMixin

    property :name

    # specifies outgoing relationships to Order
    has_n(:orders).to(Order)

    # create an index on customer--&gt;order#total_cost
    index &quot;orders.total_cost&quot;
  end

  class Order
    include Neo4j::NodeMixin

    property :total_cost

    # specifies one incoming relationship from Customer
    has_one(:customer).from(Customer, :orders)

    # create an index on the order&lt;--customer#name relationship
    index &quot;customer.name&quot;
  end
</pre>
<p>
Notice that we can index both incoming and outgoing relationships.
</p>
<p>
Let&#8216;s create a customer and one order for that customer
</p>
<pre>
    Neo4j::Transaction.run do
      cust = Customer.new
      order = Order.new
      cust.name = &quot;kalle&quot;
      order.total_cost = &quot;1000&quot;

      cust.orders &lt;&lt; order
    end
</pre>
<p>
Now we can find both Orders with a total cost between 500 and 2000 and
Customers with name &#8216;kalle&#8217; using lucene
</p>
<p>
Example:
</p>
<pre>
   customers = Customer.find('orders.total_cost' =&gt; 500..2000, 'name' =&gt; 'kalle')
</pre>
<p>
Or also possible from the other way:
</p>
<pre>
   orders = Order.find('total_cost' =&gt; 500..2000, 'customer.name' =&gt; 'kalle')
</pre>
<h3>Full text search</h3>
<p>
<a href="../classes/Neo4j.html">Neo4j</a> supports full text search by
setting the tokenized property to true on an index. (see JavaDoc for
org.apache.lucene.document.Field.Index.ANALYZED).
</p>
<pre>
  class Comment
    include Neo4j::NodeMixin

    property :comment
    index comment, :tokenized =&gt; true
  end
</pre>
<h3>Unmarshalling</h3>
<p>
The neo module will automatically unmarshalling nodes to the correct ruby
class. It does this by reading the classname property and loading that ruby
class with that node.
</p>
<pre>
  class Person
    include Neo::Node

    def hello
    end
  end

  f1 = Person.new {}

  # load the class again
  f2 = Neo4j.load(foo.neo_node_id)

  # f2 will now be new instance of Person, but will be == f1
  f1 == f2 # =&gt; true
</pre>
<h3>Reference node</h3>
<p>
There is one node that can always be find - the reference node, <a
href="../classes/Neo4j/ReferenceNode.html">Neo4j::ReferenceNode</a>.
Example:
</p>
<pre>
    Neo4j.ref_node
</pre>
<p>
This node has a relationship to all created nodes. It is used internally to
recreate an index or finding all nodes of a specific type.
</p>
<h3>Performance Issues</h3>
<p>
It is recommended to wrap several <a href="../classes/Neo4j.html">Neo4j</a>
operations including read operations in a singel transaction if possible
for better performance. Updating a lucene index can be slow. A solution to
this is to keep the index in memory instead of on disk.
</p>
<p>
I&#8216;m currently looking at how to scale neo4j.rb by a simple
master-slave cluster by using ActiveMQ (see the cluster branch). Another
solution might be to simply copy the master database (rsync ?) to the
slaves.
</p>
<h2>Ruby on Rails with Neo4j.rb</h2>
<p>
Neo4j.rb does work nicely with R&amp;R.
</p>
<p>
It has been verified on rail 2.2.2, JRuby 1.1.6 RC1, Glassfish 0.9.1.
</p>
<h3>Configuration</h3>
<h4>Install Neo4j.rb</h4>
<pre>
  gem install neo4j
</pre>
<h4>Install rails</h4>
<pre>
  gem install rails
</pre>
<h4>Create a rails project, movies</h4>
<pre>
  rails movies
</pre>
<h4>Config rails</h4>
<p>
Config rails to use Neo4j.rb instead of ActiveRecord, edit
movies/config/environment.rb environment.rb:
</p>
<pre>
  config.frameworks -= [ :active_record ] #, :active_resource, :action_mailer ]
  config.gem &quot;neo4j&quot;, :version =&gt; &quot;0.0.7&quot;
</pre>
<h4>Create Models</h4>
<p>
Create model in movies/app/models actor.rb:
</p>
<pre>
  class Role
    include Neo4j::RelationMixin
    property :title, :character
  end

  class Actor
    include Neo4j::NodeMixin
    property :name, :phone, :salary
    has_n(:acted_in).to(Movie).relation(Role)
    index :name
  end
</pre>
<p>
movie.rb:
</p>
<pre>
  class Movie
    include Neo4j::NodeMixin
    property :title
    property :year

    # defines a method for traversing incoming acted_in relationships from Actor
    has_n(:actors).from(Actor, :acted_in)
  end
</pre>
<h4>Create RESTful routes</h4>
<p>
Edit the config/routes.rb file
</p>
<pre>
  ActionController::Routing::Routes.draw do |map|
     map.resources :actors do |actor|
      actor.resources :acted_in
      actor.resource :movies, :controller =&gt; 'acted_in'
     end
</pre>
<h4>Create Controllers</h4>
<p>
Add the following controllers in app/controllers
</p>
<p>
actors_controller.rb:
</p>
<pre>
    class ActorsController &lt; ApplicationController
      before_filter :find_actor, :only =&gt; [:show, :edit, :update, :destroy]

      def index
        @actors = Actor.all.nodes
      end

      def create
        @actor = Actor.new
        @actor.update(params[:actor])
        flash[:notice] = 'Actor was successfully created.'
        redirect_to(@actor)
      end

      def update
        @actor.update(params[:actor])
        flash[:notice] = 'Actor was successfully updated.'
        redirect_to(@actor)
      end

      def destroy
        @actor.delete
        redirect_to(actors_url)
      end

      def edit
      end

      def show
      end

      def new
        @actor = Actor.value_object.new
      end

      private
      def find_actor
        @actor = Neo4j.load(params[:id])
      end
    end
</pre>
<p>
acted_in_controller.rb:
</p>
<pre>
    class ActedInController &lt; ApplicationController
      def index
        @actor = Neo4j.load(params[:actor_id])
        @movies = @actor.acted_in.nodes
      end

      def create
        @actor = Neo4j.load(params[:actor_id])
        @movie = Movie.new
        @movie.update(params[:movie])
        @actor.acted_in &lt;&lt; @movie
        flash[:notice] = 'Movie was successfully created.'
        redirect_to(@actor)
      end

      def update
        @actor = Neo4j.load(params[:actor_id])
        @movie = Movie.new
        @movie.update(params[:movie])
        @actor.acted_in.new @movie
        @movie.update(params[:movie])
        flash[:notice] = 'Movie was successfully updated.'
        redirect_to(@movie)
      end

      def show
        @movie = Neo4j.load(params[:id])
      end

      def new
        @actor = Neo4j.load(params[:actor_id])
        @movie = Movie.value_object.new
      end

      def edit
        @movie = Neo4j.load(params[:id])
      end
    end
</pre>
<h4>Add views</h4>
<p>
Add the following views in app/views/actors index.html.erb:
</p>
<pre>
    &lt;h1&gt;Listing actors&lt;/h1&gt;

    &lt;table&gt;
      &lt;tr&gt;
        &lt;th&gt;Name&lt;/th&gt;
      &lt;/tr&gt;

      &lt;% for actor in @actors %&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;%=h actor.name %&gt;&lt;/td&gt;
          &lt;td&gt;&lt;%= link_to 'Edit', edit_actor_path(actor) %&gt;&lt;/td&gt;
          &lt;td&gt;&lt;%= link_to 'Show', actor %&gt;&lt;/td&gt;
          &lt;td&gt;&lt;%= link_to 'Destroy', actor, :confirm =&gt; 'Are you sure?', :method =&gt; :delete %&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;% end %&gt;
    &lt;/table&gt;

    &lt;br /&gt;

    &lt;%= link_to 'New actor', new_actor_path %&gt;
</pre>
<p>
new.html.erb:
</p>
<pre>
    &lt;h1&gt;New Actor&lt;/h1&gt;

    &lt;% form_for(@actor) do |f| %&gt;
      &lt;p&gt;
        &lt;%= f.label :name %&gt;&lt;br /&gt;
        &lt;%= f.text_field :name %&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;%= f.label :phone %&gt;&lt;br /&gt;
        &lt;%= f.text_field :phone %&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;%= f.label :salary%&gt;&lt;br /&gt;
        &lt;%= f.text_field :salary %&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;%= f.submit &quot;Update&quot; %&gt;
      &lt;/p&gt;

    &lt;% end %&gt;

    &lt;%= link_to 'Back', actors_path %&gt;
</pre>

    </div>


   </div>


  </div>


    <!-- if includes -->

    <div id="section">





      


    <!-- if method_list -->


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>